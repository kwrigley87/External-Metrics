<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Genesys External Metrics CSV Uploader</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Genesys Cloud Platform Client SDK -->
  <script src="https://sdk-cdn.mypurecloud.com/javascript/230.0.0/purecloud-platform-client-v2.min.js"></script>
  <!-- Papa Parse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900">
  <div class="max-w-5xl mx-auto p-6">
    <header class="mb-6 flex items-center gap-3">
      <h1 class="text-2xl font-bold">External Metrics CSV Uploader</h1>
      <span class="text-xs text-gray-500">POST /api/v2/employeeperformance/externalmetrics/data</span>
    </header>

    <!-- Region + Client Id -->
    <section class="mb-4 grid md:grid-cols-3 gap-4">
      <div>
        <label class="block text-sm font-medium mb-1">Region</label>
        <select id="region" class="w-full border rounded p-2">
          <option value="mypurecloud.com">US East (mypurecloud.com)</option>
          <option value="usw2.pure.cloud">US West 2 (usw2.pure.cloud)</option>
          <option value="cac1.pure.cloud">Canada (cac1.pure.cloud)</option>
          <option value="mypurecloud.ie" selected>EU West (Ireland)</option>
          <option value="euw2.pure.cloud">EU West 2 (London)</option>
          <option value="mypurecloud.de">Germany</option>
          <option value="mypurecloud.jp">Japan (legacy)</option>
          <option value="apne2.pure.cloud">Tokyo</option>
          <option value="apne1.pure.cloud">Seoul</option>
          <option value="mypurecloud.com.au">Sydney</option>
          <option value="sae1.pure.cloud">São Paulo</option>
        </select>
      </div>
      <div class="md:col-span-2">
        <label class="block text-sm font-medium mb-1">OAuth Client Id (public)</label>
        <input id="clientId" class="w-full border rounded p-2" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" />
        <p class="text-xs text-gray-500 mt-1">Safe to expose in browser. Never put a client secret in front-end code.</p>
      </div>
    </section>

    <div class="flex gap-2 items-center mb-6">
      <button id="btnLogin"  type="button" class="px-4 py-2 rounded bg-black text-white">Sign in</button>
      <button id="btnLogout" type="button" class="px-4 py-2 rounded bg-gray-200">Sign out</button>
      <div class="ml-auto text-sm text-gray-700"><span id="whoami"></span></div>
    </div>

    <!-- CSV -->
    <section class="mb-4">
      <label class="block text-sm font-medium mb-1">CSV file</label>
      <input id="csvFile" type="file" accept=".csv" class="block w-full text-sm" />
      <p class="text-xs text-gray-500 mt-1">
        Header: <code>metricId,userId,email,value,type,dateOccurred</code>.
        <strong>type</strong>: <code>total</code> (default) or <code>cumulative</code>.
        Provide <em>userId</em> OR <em>email</em> (not both). Date as <code>YYYY-MM-DD</code>.
      </p>
    </section>

    <!-- Controls -->
    <section class="grid md:grid-cols-4 gap-4 mb-4">
      <div>
        <label class="block text-sm font-medium mb-1">Max concurrency (1–5)</label>
        <input id="concurrency" type="number" min="1" max="5" value="3" class="w-full border rounded p-2" />
        <p class="text-xs text-gray-500 mt-1"># of 100-row batches sent in parallel. Default 3.</p>
      </div>
      <div class="md:col-span-3 flex items-end gap-2">
        <button id="btnValidate" type="button" class="px-4 py-2 rounded bg-blue-600 text-white">Validate CSV</button>
        <button id="btnUpload"   type="button" class="px-4 py-2 rounded bg-green-600 text-white" disabled>Upload to Genesys</button>
        <button id="btnCancel"   type="button" class="px-4 py-2 rounded bg-gray-200" disabled>Cancel</button>
      </div>
    </section>

    <!-- Progress -->
    <section class="mb-2">
      <div class="text-sm font-medium">Progress</div>
      <div class="w-full bg-gray-200 rounded h-3">
        <div id="bar" class="bg-green-500 h-3 rounded" style="width:0%"></div>
      </div>
      <div id="stats" class="text-xs text-gray-600 mt-1">Waiting…</div>
    </section>

    <!-- Preview / Log -->
    <details class="mt-4" open>
      <summary class="cursor-pointer font-medium">Preview & Log</summary>
      <pre id="log" class="mt-2 p-3 bg-white border rounded overflow-auto text-xs h-64"></pre>
    </details>
  </div>

<script>
/* --- tiny logger that works before/after DOM is ready --- */
function _log(msg) {
  const ts = new Date().toISOString();
  const line = `[${ts}] ${msg}\n`;
  const el = document.getElementById('log');
  if (el) { el.textContent += line; el.scrollTop = el.scrollHeight; }
  else { console.log(line); }
}

/* --- main initializer: runs now if DOM ready, otherwise after DOMContentLoaded --- */
(function bootstrap() {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

function init() {
  _log('App initialised');

  // Wire buttons immediately
  const btnLogin   = document.getElementById('btnLogin');
  const btnLogout  = document.getElementById('btnLogout');
  const btnValidate= document.getElementById('btnValidate');
  const btnUpload  = document.getElementById('btnUpload');
  const btnCancel  = document.getElementById('btnCancel');

  btnLogin.addEventListener('click', onLogin);
  btnLogout.addEventListener('click', onLogout);
  btnValidate.addEventListener('click', onValidate);
  btnUpload.addEventListener('click', onUpload);
  btnCancel.addEventListener('click', () => { state.cancelRequested = true; });

  // State
  window.state = {
    platformAvailable: !!(window.platformClient && window.platformClient.ApiClient),
    client: null,
    usersApi: null,
    authedUser: null,
    parsedRows: [],
    cancelRequested: false
  };

  // If SDK is present, init it; otherwise keep CSV tools working and warn on sign-in.
  if (state.platformAvailable) {
    state.client   = window.platformClient.ApiClient.instance;
    state.usersApi = new window.platformClient.UsersApi();
  } else {
    _log('WARNING: Genesys SDK failed to load. CSV validation will work, but Sign in/Upload will not.');
  }

  // Restore persisted region/clientId
  const LS_KEYS = { region: 'extm_region', clientId: 'extm_clientId' };
  const regionEl = document.getElementById('region');
  const clientEl = document.getElementById('clientId');
  regionEl.value = localStorage.getItem(LS_KEYS.region) || regionEl.value;
  clientEl.value = new URLSearchParams(location.search).get('clientId')
                || localStorage.getItem(LS_KEYS.clientId) || '';

  // Helpful global error pipe to the on-page log
  window.onerror = (msg, src, line, col, err) => {
    const details = [msg, src, line + ':' + col, err && err.stack].filter(Boolean).join(' | ');
    _log('JS Error → ' + details);
  };

  async function onLogin() {
    if (!state.platformAvailable) { alert('Genesys SDK not loaded. Check the SDK script tag / network.'); return; }

    const region   = regionEl.value.trim();
    const clientId = clientEl.value.trim();
    if (!clientId) return alert('Enter OAuth Client Id');

    // persist
    localStorage.setItem(LS_KEYS.region, region);
    localStorage.setItem(LS_KEYS.clientId, clientId);

    state.client.setEnvironment(region);

    // Use a fixed redirect to match OAuth config exactly
    const redirectUri = `${location.origin}${location.pathname}`;
    _log('Auth starting… redirectUri=' + redirectUri);

    try {
      await state.client.loginImplicitGrant(clientId, redirectUri, { state: 'ext-metrics' });
      state.authedUser = await state.usersApi.getUsersMe({});
      document.getElementById('whoami').textContent = `Welcome, ${state.authedUser.name}`;
      _log(`Auth OK for ${state.authedUser.name}`);
    } catch (e) {
      _log('Auth FAILED → ' + (e && e.message ? e.message : e));
      alert('Sign-in failed. Ensure OAuth Redirect URI exactly matches this page URL. See log.');
    }
  }

  async function onLogout() {
    if (!state.platformAvailable) return;
    try { await state.client.logout(true); } catch {}
    state.authedUser = null;
    document.getElementById('whoami').textContent = '';
    _log('Signed out');
  }

  async function onValidate() {
    const file = document.getElementById('csvFile').files && document.getElementById('csvFile').files[0];
    if (!file) return alert('Choose a CSV file first.');
    try {
      state.parsedRows = await parseCsv(file);
      const issues = validateRows(state.parsedRows);
      if (issues.length) {
        _log('Validation issues:\n' + issues.join('\n'));
        alert(`Found ${issues.length} validation issue(s). See log.`);
        document.getElementById('btnUpload').disabled = false; // set true to block on errors
      } else {
        _log(`Validation OK. ${state.parsedRows.length} row(s) ready.`);
        document.getElementById('btnUpload').disabled = false;
      }
    } catch (e) {
      _log('CSV parse failed → ' + (e && e.message ? e.message : e));
      alert('CSV parse failed (see log).');
    }
  }

  async function onUpload() {
    if (!state.platformAvailable) return alert('Sign in first (SDK not loaded or not authenticated).');
    if (!state.client.getAuthToken()) return alert('Please sign in first.');
    if (!state.parsedRows.length) return alert('Validate your CSV first.');

    state.cancelRequested = false;
    document.getElementById('btnCancel').disabled = false;

    const items = state.parsedRows.map(r => ({
      metricId: r.metricId,
      value: Number(r.value),
      type: (r.type || 'total').toLowerCase(),
      dateOccurred: r.dateOccurred,
      userId: r.userId || undefined,
      email: r.email || undefined
    }));

    const chunks = [];
    for (let i = 0; i < items.length; i += 100) chunks.push(items.slice(i, i + 100));

    const maxConcurrency = Math.min(Number(document.getElementById('concurrency').value || 3), 5);
    let done = 0, ok = 0, failed = 0;

    _log(`Starting upload: ${items.length} rows in ${chunks.length} batch(es), concurrency=${maxConcurrency}`);
    updateProgress(0, chunks.length, 0, 0);

    const queue = chunks.map((payload, idx) => ({ idx: idx + 1, payload }));

    async function worker() {
      while (queue.length && !state.cancelRequested) {
        const job = queue.shift();
        if (!job) break;
        try {
          await postChunk(job.idx, job.payload);
          ok++; _log(`Batch ${job.idx}: OK (${job.payload.length} items)`);
        } catch (e) {
          failed++; _log(`Batch ${job.idx}: FAILED → ${e.message || e}`);
        } finally {
          done++; updateProgress(done, chunks.length, ok, failed);
        }
      }
    }

    await Promise.all(Array.from({ length: maxConcurrency }, () => worker()));
    document.getElementById('btnCancel').disabled = true;

    if (state.cancelRequested) { _log('Upload cancelled by user.'); alert('Upload cancelled.'); }
    else if (failed === 0)     { _log('All batches uploaded successfully ✅'); alert('Upload complete!'); }
    else                       { _log('Upload completed with failures. See log.'); alert(`Upload finished. ${failed} batch(es) failed.`); }
  }

  function updateProgress(done, total, ok, failed) {
    const pct = total ? Math.round((done / total) * 100) : 0;
    document.getElementById('bar').style.width = pct + '%';
    document.getElementById('stats').textContent = `Batches: ${done}/${total} • OK: ${ok} • Failed: ${failed}`;
  }

  function parseCsv(file) {
    _log(`Parsing: ${file.name} (${Math.round(file.size/1024)} KB)`);
    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        transformHeader: h => h.trim(),
        transform: v => typeof v === 'string' ? v.trim() : v,
        complete: results => resolve(results.data || []),
        error: err => reject(err)
      });
    });
  }

  function validateRows(rows) {
    const errs = [];
    rows.forEach((r, i) => {
      const row = i + 2; // header is row 1
      if (!r.metricId) errs.push(`Row ${row}: metricId is required (External ID from External Metric Definitions)`);
      if (!r.userId && !r.email) errs.push(`Row ${row}: either userId or email is required`);
      if (r.userId && r.email) errs.push(`Row ${row}: provide userId OR email, not both`);
      if (r.value === undefined || r.value === '') errs.push(`Row ${row}: value is required`);
      if (r.value && isNaN(Number(r.value))) errs.push(`Row ${row}: value must be numeric`);
      if (r.type && !['total','cumulative'].includes(String(r.type).toLowerCase()))
        errs.push(`Row ${row}: type must be total|cumulative`);
      if (!r.dateOccurred || !/^\d{4}-\d{2}-\d{2}$/.test(r.dateOccurred))
        errs.push(`Row ${row}: dateOccurred must be YYYY-MM-DD`);
    });
    return errs;
  }

  async function postChunk(batchNumber, items) {
    const url  = state.client.basePath + '/api/v2/employeeperformance/externalmetrics/data';
    const body = JSON.stringify({ items });

    let attempt = 0, maxAttempts = 5;
    while (true) {
      attempt++;
      const res = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + state.client.getAuthToken(),
          'Content-Type': 'application/json'
        },
        body
      });

      if (res.ok) return;

      if ((res.status === 429 || res.status >= 500) && attempt < maxAttempts) {
        const retryAfter = Number(res.headers.get('Retry-After')) || 0;
        const backoff = retryAfter ? retryAfter * 1000 : Math.min(30000, 1000 * Math.pow(2, attempt));
        _log(`Batch ${batchNumber}: attempt ${attempt} got ${res.status}. Retrying in ${Math.round(backoff/1000)}s…`);
        await new Promise(r => setTimeout(r, backoff));
        continue;
      }

      let msg = `${res.status} ${res.statusText}`;
      try { const t = await res.text(); if (t) msg += ` | ${t.substring(0, 500)}`; } catch {}
      throw new Error(msg);
    }
  }
}
</script>
</body>
</html>
